# Отладка и профилирование программ на Python

## Содержание практики

1. Изучить: основные методы отладки программ на языке Python, включая использование встроенных и сторонних инструментов, и подходы к выявлению ошибок в коде.
2. Ознакомиться: с библиотеками для анализа работы кода и современными инструментами отладки, такими как интегрированные среды разработки (IDE) с поддержкой дебаггинга, и их функционалом для упрощения процесса.
3. Практически выполнить: подготовить примеры программ, которые нужно проанализировать, и отладить их с целью научиться пользоваться инструментами отладки кода. 


## 1. Изучение

Текст и скриншоты.

## 2. Ознакомление

Разделим инструменты на три категории: отладчики, профайлеры, линтеры. \
Кроме них также стоит упомянуть: **PyPy**, **Cython**, **Jython**, интеграции с **C/Rust/Fortran** 

### Отладчики

Кто такие отладчики?

[pdb (Python Debugger)](./debuggers/pdb.md)

[print](./debuggers/print.md)

[logging](./debuggers/logging.md)

[Pycharm](./debuggers/pycharm.md)

[VS Code](./debuggers/vscode.md)

[IPython](./debuggers/ipython.md)

[Jupyter Notebook](./debuggers/jupyter-notebook.md)

[Eclipse с PyDev](./debuggers/eclipse-pydev.md)

[pytest](./debuggers/pytest.md)

[unittest](./debuggers/unittest.md)

### Профайлеры

Профилирование — это процесс анализа работы программы для выявления узких мест и возможностей для оптимизации.
Обычно профилирование применяют, когда программа работает медленнее, чем ожидалось, или потребляет слишком много ресурсов, таких как процессорное время или память.

Для чего нужно профилирование? Оно позволяет собрать данные о поведении программы, чтобы понять, какие её части требуют улучшения.
Среди характеристик, которые можно измерить:
- Время выполнения отдельных строк кода.
- Частота вызовов функций и их продолжительность.
- Иерархия вызовов (какие функции вызывают другие).
- Участки кода, где программа тратит больше всего времени («hot spots», «горячие точки»).
- Использование процессора, памяти или других системных ресурсов (например, доступ к файлам).

Профайлеры делятся на два основных типа: **статистические** (statistical) и **событийные** (deterministic, event-based).
Каждый из них имеет свои особенности, преимущества и ограничения.

#### Статистический профайлер

Статистический профайлер собирает данные, периодически «заглядывая» в программу через небольшие интервалы времени.
Он фиксирует, какая инструкция выполняется в данный момент, и сохраняет эту информацию (так называемые «сэмплы»).
Это похоже на моментальные снимки, которые затем анализируются, чтобы выявить наиболее активные участки кода.

##### Пример работы

Представьте, что профайлер делает снимок каждую миллисекунду.
Если какая-то функция выполняется часто или долго, она будет чаще попадать в эти снимки, что укажет на её «вес» в программе.

##### Проблемы и ограничения

- Недостаточная точность. Если интервал между снимками слишком большой, профайлер может пропустить короткие, но частые вызовы функций. Например, функция, которая выполняется быстро, но вызывается тысячи раз, может остаться незамеченной.
- Сложность оценки времени. Статистический профайлер не измеряет время выполнения напрямую, поэтому трудно понять, вызывается ли функция часто или просто работает долго.
- Долгий сбор данных. Для получения достоверной картины нужно много снимков, что требует времени.
- Ограниченный инструментарий. Инструментов для анализа данных статистических профайлеров меньше, чем для событийных.

##### Преимущества

Несмотря на недостатки, статистические профайлеры отлично справляются с поиском «горячих точек» - мест, где программа тратит больше всего ресурсов.
Их главное достоинство - минимальное влияние на работу программы.
Это делает их подходящими даже для использования в реальных условиях (например, на серверах в продакшене).
В Python такие профайлеры могут собирать полные стектрейсы, что даёт более глубокое понимание происходящего в коде.

[py-spy](./profilers/py-spy.md)


#### Событийный профайлер

Событийный профайлер работает иначе: он отслеживает каждое значимое событие в программе, такое как вызов функции, её завершение или возникновение исключения.
Он записывает, сколько времени прошло между этими событиями, и сохраняет данные для анализа.


##### Пример работы

Если программа вызывает функцию `calculate()`, событийный профайлер зафиксирует момент входа в функцию, момент выхода и точное время выполнения.
Также он учтёт, сколько раз функция была вызвана.

##### Проблемы и ограничения

- Сильное влияние на программу. Так как профайлер вмешивается в каждый шаг выполнения, программа может замедляться в разы. Это делает событийные профайлеры почти непригодными для продакшена.
- Изменение поведения. В редких случаях вмешательство профайлера может даже повлиять на логику работы программы.

##### Преимущества

Событийные профайлеры дают полную картину работы программы: точное время выполнения каждой функции, количество вызовов, граф зависимостей между функциями.
Это помогает не только найти узкие места, но и выявить проблемы в архитектуре или алгоритмах.
Удобные интерфейсы для анализа и обилие инструментов делают их популярными среди разработчиков.

[cProfile](./profilers/cProfile.md)

[timeit](./profilers/timeit.md)

[line_profiler](./profilers/line_profiler.md)

[memory_profiler](./profilers/memory_profiler.md)

[pyheat](./profilers/pyheat.md)


### Линтеры

Кто такие линтеры?

[pylint](./linters/pylint.md)

[flake8](./linters/flake8.md)

[ruff](./linters/ruff.md)

[mypy](./linters/mypy.md)


### Остальное

Кто такие и почему?

[PyPy](./other/pypy.md)

[Cython](./other/cython.md)

[Интеграция с C](./other/c.md)

[Интеграция с Rust](./other/rust.md)

[Интеграция с Fortran](./other/fortran.md)

## 3. Примеры

Текст и скриншоты
