# 2. Ознакомление

Разделим инструменты на три категории: отладчики, профайлеры, линтеры.
Кроме них также стоит упомянуть: **PyPy**, **Cython**, **Jython** и интеграции с **C/Rust/Fortran** 

## Отладчики

Отладчик - инструмент, который помогает отлаживать (искать ошибки) программу.

Отладка - это процесс, при котором разработчик ищет и устраняет ошибки (баги) в программе.
Даже опытные программисты сталкиваются с ошибками, и эффективные инструменты отладки помогают быстрее находить их источник.
В Python доступен широкий спектр методов и инструментов, от простых, таких как вывод сообщений в консоль, до продвинутых отладчиков в интегрированных средах разработки (IDE).

### [pdb (Python Debugger)](../debuggers/pdb.md)

### [print](../debuggers/print.md)

### [logging](../debuggers/logging.md)

### [pytest](../debuggers/pytest.md)

### [unittest](../debuggers/unittest.md)

### [Pycharm](../debuggers/pycharm.md)

### [VS Code](../debuggers/vscode.md)

### [IPython](../debuggers/ipython.md)

### [Jupyter Notebook](../debuggers/jupyter-notebook.md)

## Профайлеры

Профилирование — это процесс анализа работы программы для выявления узких мест и возможностей для оптимизации.
Обычно профилирование применяют, когда программа работает медленнее, чем ожидалось, или потребляет слишком много ресурсов, таких как процессорное время или память.

Для чего нужно профилирование? Оно позволяет собрать данные о поведении программы, чтобы понять, какие её части требуют улучшения.
Среди характеристик, которые можно измерить:

- Время выполнения отдельных строк кода.
- Частота вызовов функций и их продолжительность.
- Иерархия вызовов (какие функции вызывают другие).
- Участки кода, где программа тратит больше всего времени («hot spots», «горячие точки»).
- Использование процессора, памяти или других системных ресурсов (например, доступ к файлам).

Профайлеры делятся на два основных типа: **статистические** (statistical) и **событийные** (deterministic, event-based).
Каждый из них имеет свои особенности, преимущества и ограничения.

### Статистические профайлеры

Статистические профайлеры собирают данные, периодически «заглядывая» в программу через небольшие интервалы времени.
Они фиксируют, какая инструкция выполняется в данный момент, и сохраняют эту информацию (так называемые «сэмплы»).
Это похоже на моментальные снимки, которые затем анализируются, чтобы выявить наиболее активные участки кода.

#### Пример работы

Представьте, что профайлер делает снимок каждую миллисекунду.
Если какая-то функция выполняется часто или долго, она будет чаще попадать в эти снимки, что укажет на её «вес» в программе.

#### Проблемы и ограничения

- Недостаточная точность. Если интервал между снимками слишком большой, профайлер может пропустить короткие, но частые вызовы функций. Например, функция, которая выполняется быстро, но вызывается тысячи раз, может остаться незамеченной.
- Сложность оценки времени. Статистический профайлер не измеряет время выполнения напрямую, поэтому трудно понять, вызывается ли функция часто или просто работает долго.
- Долгий сбор данных. Для получения достоверной картины нужно много снимков, что требует времени.
- Ограниченный инструментарий. Инструментов для анализа данных статистических профайлеров меньше, чем для событийных.

#### Преимущества

Несмотря на недостатки, статистические профайлеры отлично справляются с поиском «горячих точек» - мест, где программа тратит больше всего ресурсов.
Их главное достоинство - минимальное влияние на работу программы.
Это делает их подходящими даже для использования в реальных условиях (например, на серверах в продакшене).
В Python такие профайлеры могут собирать полные стектрейсы, что даёт более глубокое понимание происходящего в коде.


### [py-spy](../profilers/py-spy.md)


### Событийные профайлеры

Событийные профайлеры работают иначе: они отслеживают каждое значимое событие в программе, такое как вызов функции, её завершение или возникновение исключения.
Они записывают, сколько времени прошло между этими событиями, и сохраняют данные для анализа.

#### Пример работы

Если программа вызывает функцию `calculate()`, событийный профайлер зафиксирует момент входа в функцию, момент выхода и точное время выполнения.
Также он учтёт, сколько раз функция была вызвана.

#### Проблемы и ограничения

- Сильное влияние на программу. Так как профайлер вмешивается в каждый шаг выполнения, программа может замедляться в разы. Это делает событийные профайлеры почти непригодными для продакшена.
- Изменение поведения. В редких случаях вмешательство профайлера может даже повлиять на логику работы программы.

#### Преимущества

Событийные профайлеры дают полную картину работы программы: точное время выполнения каждой функции, количество вызовов, граф зависимостей между функциями.
Это помогает не только найти узкие места, но и выявить проблемы в архитектуре или алгоритмах.
Удобные интерфейсы для анализа и обилие инструментов делают их популярными среди разработчиков.


### [cProfile](../profilers/cProfile.md)

### [timeit](../profilers/timeit.md)

### [line_profiler](../profilers/line_profiler.md)

### [memory_profiler](../profilers/memory_profiler.md)

### [pyheat](../profilers/pyheat.md)


## Линтеры

Линтеры - это инструменты статического анализа кода, которые помогают разработчикам находить потенциальные ошибки, стилистические проблемы и несоответствия стандартам ещё до запуска программы.
Они сканируют исходный код, выявляя такие проблемы, как неправильное форматирование, неиспользуемые переменные, потенциальные баги или отклонения от принятых в команде правил.
Линтеры особенно популярны в языках программирования, таких как Python, где свобода синтаксиса может привести к неоднородному или небезопасному коду.

Основная задача линтеров - повысить качество и читаемость кода, а также снизить вероятность ошибок на этапе выполнения.
Они интегрируются в редакторы кода (например, VS Code или PyCharm) или процессы непрерывной интеграции (CI/CD), предоставляя мгновенную обратную связь.
Например, линтер может указать на отсутствие пробела после запятой или предупредить о сложной конструкции, которая может быть трудно читаемой.

Линтеры также экономят время, позволяя исправлять мелкие недочёты автоматически или до начала отладки.
Популярные линтеры для Python, такие как `flake8`, `pylint`, `ruff` или `mypy`, предлагают гибкую настройку под нужды проекта, поддерживая стандарты, такие как PEP 8.
Использование линтеров помогает не только улучшить код, но и воспитать у разработчиков привычку писать аккуратный и надёжный код, что особенно важно в крупных и долгосрочных проектах.

### [pylint](../linters/pylint.md)

### [flake8](../linters/flake8.md)

### [ruff](../linters/ruff.md)

### [mypy](../linters/mypy.md)


## Остальное

В дополнение к основным инструментам отладки и профилирования, существуют технологии, которые используются реже из-за своей специфичности и редкой необходимости.
Эти технологии открывают новые возможности для оптимизации и анализа производительности программ.
Они особенно полезны в высокопроизводительных вычислениях, где стандартные инструменты могут быть недостаточно эффективны, или в проектах, требующих глубокого взаимодействия с низкоуровневыми языками.

### [PyPy](../other/pypy.md)

### [Cython](../other/cython.md)

### [Интеграция с C](../other/c.md)

### [Интеграция с Rust](../other/rust.md)

### [Интеграция с Fortran](../other/fortran.md)